# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GePoBVNBT3M-b_Ya_j4Q0xhKkPegN-OK
"""

# Download the dataset
songs = mdl.lab1.load_training_data()

# Print one of the songs to inspect it in greater detail!
example_song = songs[0]
print("\nExample song: ")
print(example_song)

# Commented out IPython magic to ensure Python compatibility.
# Import Tensorflow 2.0
# %tensorflow_version 2.x
import tensorflow as tf 

# Download and import the MIT 6.S191 package
!pip install mitdeeplearning
import mitdeeplearning as mdl

# Import all remaining packages
import numpy as np
import os
import time
import functools
from IPython import display as ipythondisplay
from tqdm import tqdm
!apt-get install abcmidi timidity > /dev/null 2>&1

# Check that we are using a GPU, if not switch runtimes
#   using Runtime > Change Runtime Type > GPU

#assert len(tf.config.list_physical_devices('GPU')) > 0

# Convert the ABC notation to audio file and listen to it
mdl.lab1.play_song(example_song)

# Join our list of song strings into a single string containing all songs
songs_joined = "\n\n".join(songs) 

# Find all unique characters in the joined string
vocab = sorted(set(songs_joined))
print("There are", len(vocab), "unique characters in the dataset")

print(len(songs))
print(len(set(songs)))

# 궁금증? set(songs_joined) 에서 집합 원소로 중복을 제외하는건 알겠는데 왜 817개가 83개가 되지??

### Define numerical representation of text ###

# Create a mapping from character to unique index.
# For example, to get the index of the character "d", 
#   we can evaluate `char2idx["d"]`.  
char2idx = {u:i for i, u in enumerate(vocab)}

#enumerate 는 반복문 range 같은거. 원소 속 index 와 value 를 튜플 형태로 반환한다.
# list = ['a','b','c']
# for i in enumerate(list) -> (0,'a') , (1,'b') , (2,'c')

# Create a mapping from indices to characters. This is
#   the inverse of char2idx and allows us to convert back
#   from unique index to the character in our vocabulary.
idx2char = np.array(vocab)

# vocab 이란 sorted(set(songs_joined))
#print(vocab)
#print(songs_joined)

# 따라서 곡 정보임.

print(char2idx)
print(len(char2idx))

print(idx2char)
print(len(idx2char))

print('{')
for char,_ in zip(char2idx, range(20)):
    print('  {:4s}: {:3d},'.format(repr(char), char2idx[char]))
print('  ...\n}')

# zip함수 -> 여러 리스트를 한 zip type(자료형) 으로 묶음
# # 예를 들면 # iterable자료형
# >>> num = [1, 2, 3]
# >>> fruit = ['apple', 'banana', 'orange']
# >>> color = ['red', 'yellow', 'orange']
#  # zip함수로 묶어줌
# >>> zip_list = zip(num, fruit, color)
# >>> print(zip_list, type(zip_list))
# <zip object at 0x0000020180766048> <class 'zip'>  #zip 타입으로 출력

# >>> print(list(zip_list))  # list 타입으로 변환
# [(1, 'apple', 'red'), (2, 'banana', 'yellow'), (3, 'orange', 'orange')]

# # comprehesion 예시, dict 형식으로 리턴
# >>> dict_num = { x:y for x, y in zip(range(10),range(10))}
# {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9}

### Vectorize the songs string ###

'''TODO: Write a function to convert the all songs string to a vectorized
    (i.e., numeric) representation. Use the appropriate mapping
    above to convert from vocab characters to the corresponding indices.

  NOTE: the output of the `vectorize_string` function 
  should be a np.array with `N` elements, where `N` is
  the number of characters in the input string
'''
def vectorize_string(string):
  vectorized_output = np.array([char2idx[char] for char in string])
  return vectorized_output

# string(곡 정보) = songs_joined
# 곡 정보에서 char(문자) 가 있다면 char2idx[char] (해당 문자(key)에 대응하는 숫자(value) 반환)
# 그걸 ndarray로 반환.

# def vectorize_string(string):
  # TODO

vectorized_songs = vectorize_string(songs_joined)

print ('{} ---- characters mapped to int ----> {}'.format(repr(songs_joined[:10]), vectorized_songs[:10]))
# check that vectorized_songs is a numpy array
assert isinstance(vectorized_songs, np.ndarray), "returned result should be a numpy array"

